class_name ClientNetwork extends Network

################################################################################
#                        Copyright 2022-2023 ArchaicSoft                       #
#                                                                              #
# Boost Software License - Version 1.0 - August 17th, 2003                     #
#                                                                              #
# Permission is hereby granted, free of charge, to any person or organization  #
# obtaining a copy of the software and accompanying documentation covered by   #
# this license (the "Software") to use, reproduce, display, distribute,        #
# execute, and transmit the Software, and to prepare derivative works of the   #
# Software, and to permit third-parties to whom the Software is furnished to   #
# do so, all subject to the following:                                         #
#                                                                              #
# The copyright notices in the Software and this entire statement, including   #
# the above license grant, this restriction and the following disclaimer,      #
# must be included in all copies of the Software, in whole or in part, and     #
# all derivative works of the Software, unless such copies or derivative       #
# works are solely in the form of machine-executable object code generated by  #
# a source language processor.                                                 #
#                                                                              #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     #
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT    #
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE    #
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,  #
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  #
# DEALINGS IN THE SOFTWARE.                                                    #
################################################################################

# remote accessors

@rpc("authority", "reliable", "call_remote", 0)
func client_receive_reliable(header: Packet.Server, args: Array[Variant]) -> void:
	_receive_data(header, args)

@rpc("authority", "unreliable", "call_remote", 1)
func client_receive_unreliable(header: Packet.Server, args: Array[Variant]) -> void:
	_receive_data(header, args)

##
# User-Defined event for interacting on a successful connection attempt.
##
func _connection_succeeded() -> void: pass

##
# User-Defined event for interacting on a failed connection attempt.
##
func _connection_failed() -> void: pass

##
# User-Defined event for interacting on a connection termination.
##
func _connection_ended() -> void: pass

##
# Initialize a new socket object and attempts a connection.
#
# Params:
#         ip:            The ip the server is located on.
#         port:          The port used to connect to the server.
#         bandwidth_in:  (Optional) Limit bandwidth allowed in. 0 for none.
#         bandwidth_out: (Optional) Limit bandwidth allowed out. 0 for none.
#         ssl_cert:      (Optional) Full path to the '.crt' file used to connect.
#         ssl_host:      (Optional) Host name used to verify crt.
#         ssl_verify:    (Optional) 3rd party extra integrity check.
#
# Returns: If the socket initialization was successful or not.
##
func initialize(
	ip: String,
	port: int,
	bandwidth_in: int = 0,
	bandwidth_out: int = 0,
	ssl_cert: String = "",
	ssl_host: String = "",
	ssl_verify: bool = false
) -> bool:
	var socket := ENetMultiplayerPeer.new()
	
	log_debug("Initializing network started.")
	
	if socket.create_client(ip, port, 2, bandwidth_in, bandwidth_out) != OK:
		log_debug("\tFailed to initialize... Port may currently be in use!")
		return false # error
	
	# load tls data
	if ssl_cert.strip_escapes().length() > 0 and ssl_host.strip_escapes().length() > 0:
		log_debug("\tActivating network security.")
		socket.get_host().dtls_client_setup(
			ssl_host,
			TLSOptions.client(load(ssl_cert)) if ssl_verify else null
		)
		log_debug("\t\tSuccessfully activated security!")
	
	# connect peer events
	socket.peer_disconnected.connect(func(): _connection_failed(); terminate())
	socket.peer_connected.connect(
		func(id: int):
			await get_tree().process_frame
			_connection_succeeded()
	)
	
	multiplayer.set_multiplayer_peer(socket)
	return true # there were no errors

##
# Terminates the current active networking socket.
##
func terminate() -> void:
	if socket_connected():
		get_socket().close_connection()
	multiplayer.set_multiplayer_peer(null)

##
# Receives a packet by header, and passes any args to the handler for the packet. If this packet is invalid, it will be refused.
#
# Params:
#         header     : The packet header defined in the Packet.Server enum.
#         args       : The packet data or arguments if any.
##
func _receive_data(header: Packet.Server, args: Array[Variant]) -> void:
	# try to route the function
	if callv("receive_" + Packet.Server.keys()[header], args) == true:
		return
	
	# if we reach this, we had an error calling the function or
	# we returned false intentionally from the function to signify
	# an invalid call state.
	socket_disconnect()
	
	# debug printing
	log_debug(
		"A packet was refused... Packet info dump following:\n%s: %s" %
		[Packet.Server.keys()[header], args]
	)

##
# Returns the current state of the active socket connection.
##
func socket_state() -> int:
	var socket := get_socket()
	if not is_instance_valid(socket):
		return ENetPacketPeer.STATE_DISCONNECTED
	
	if 1 not in multiplayer.get_peers():
		return ENetPacketPeer.STATE_DISCONNECTED
	
	var peer := socket.get_peer(1)
	if not is_instance_valid(peer):
		return ENetPacketPeer.STATE_DISCONNECTED
	
	return peer.get_state()

##
# Returns if the current active socket connection is connected or not.
##
func socket_connected() -> bool:
	return socket_state() == ENetPacketPeer.STATE_CONNECTED

##
# Ends the current active socket connection if connected.
##
func socket_disconnect() -> void:
	terminate()
	
	# notify the connection loss
	_connection_ended()

##
# Sends a packet to the server. Assumes connection is active when invoked, and will invoke _connection_ended if connection is not detected.
#
# Params:
#         header     : The packet header defined in the Packet.Client enum.
#         args       : The packet data or arguments if any.
#         unreliable : Opts to allow unreliable transport. Good for speed, dangerous for syncrosity.
#         channel    : The channel number to send on.
##
func socket_send(
	header     : Packet.Client,
	args       : Array[Variant] = [],
	unreliable : bool = false,
	channel    : int = 1
) -> void:
	# check for disconnect
	if not socket_connected():
		_connection_ended()
		return
	
	var fn = "server_receive_%sreliable_channel_%s" % [("un" if unreliable else ""), str(clamp(channel, 1, 2))]
	rpc_id(1, fn, header, args)
