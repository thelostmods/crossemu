class_name HybridNetwork extends Network

################################################################################
#                        Copyright 2022-2023 ArchaicSoft                       #
#                                                                              #
# Boost Software License - Version 1.0 - August 17th, 2003                     #
#                                                                              #
# Permission is hereby granted, free of charge, to any person or organization  #
# obtaining a copy of the software and accompanying documentation covered by   #
# this license (the "Software") to use, reproduce, display, distribute,        #
# execute, and transmit the Software, and to prepare derivative works of the   #
# Software, and to permit third-parties to whom the Software is furnished to   #
# do so, all subject to the following:                                         #
#                                                                              #
# The copyright notices in the Software and this entire statement, including   #
# the above license grant, this restriction and the following disclaimer,      #
# must be included in all copies of the Software, in whole or in part, and     #
# all derivative works of the Software, unless such copies or derivative       #
# works are solely in the form of machine-executable object code generated by  #
# a source language processor.                                                 #
#                                                                              #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     #
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT    #
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE    #
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,  #
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  #
# DEALINGS IN THE SOFTWARE.                                                    #
################################################################################

# remote accessors

@rpc("any_peer", "reliable", "call_remote", 0)
func hybrid_receive_reliable_channel_1(header: Packet.Hybrid, args: Array[Variant]) -> void:
	_receive_data(multiplayer.get_remote_sender_id(), header, args)

@rpc("any_peer", "reliable", "call_remote", 1)
func hybrid_receive_reliable_channel_2(header: Packet.Hybrid, args: Array[Variant]) -> void:
	_receive_data(multiplayer.get_remote_sender_id(), header, args)

@rpc("any_peer", "unreliable", "call_remote", 2)
func hybrid_receive_unreliable_channel_1(header: Packet.Hybrid, args: Array[Variant]) -> void:
	_receive_data(multiplayer.get_remote_sender_id(), header, args)

@rpc("any_peer", "unreliable", "call_remote", 3)
func hybrid_receive_unreliable_channel_2(header: Packet.Hybrid, args: Array[Variant]) -> void:
	_receive_data(multiplayer.get_remote_sender_id(), header, args)

##
# User-Defined event for interacting on a successful joiner-side connection attempt.
##
func _connection_succeeded() -> void: pass

##
# User-Defined event for interacting on a failed joiner-side connection attempt.
##
func _connection_failed() -> void: pass

##
# User-Defined event for interacting on a joiner-side connection termination.
##
func _connection_ended() -> void: pass

##
# User-Defined event for interacting on a host-side peer connect signal.
#
# Params:
#         id: ENet socket connetion uuid.
##
func _peer_connected(id: int) -> void: pass

##
# User-Defined event for interacting on a host-side peer disconnect signal.
#
# Params:
#         id: ENet socket connetion uuid.
##
func _peer_disconnected(id: int) -> void: pass

##
# Returns if the active socket is a session host.
##
func is_host() -> bool: return _is_host
var _is_host : bool

##
# Initialize a new socket object and listens for connections.
#
# Params:
#         port:          The port used to connect to the host.
#         max_clients:   Limit of client connections allowed.
#         bandwidth_in:  (Optional) Limit bandwidth allowed in. 0 for none.
#         bandwidth_out: (Optional) Limit bandwidth allowed out. 0 for none.
#         ssl_pkey:      (Optional) Full path to the '.key' file used to service.
#         ssl_cert:      (Optional) Full path to the '.crt' file used to service.
#
# Returns: If the socket initialization was successful or not.
##
func host(
	port: int,
	max_clients: int,
	bandwidth_in: int = 0,
	bandwidth_out: int = 0,
	ssl_pkey: String = "",
	ssl_cert: String = ""
) -> bool:
	var socket := ENetMultiplayerPeer.new()
	
	log_status("Initializing network started.")
	
	if socket.create_server(port, max_clients, 4, bandwidth_in, bandwidth_out) != OK:
		log_status("\tFailed to initialize... Port may currently be in use!")
		return false # error
	
	# load tls data
	if ssl_pkey.strip_escapes().length() > 0 and ssl_cert.strip_escapes().length() > 0:
		log_status("\tActivating network security.")
		socket.get_host().dtls_server_setup(
			TLSOptions.server(load(ssl_pkey), load(ssl_cert))
		)
		log_status("\t\tSuccessfully activated security!")
	
	log_status("\tApplying final steps to the network.")
	
	# connect peer events
	socket.peer_disconnected.connect(_peer_disconnected)
	socket.peer_connected.connect(
		func(id:int):
			await get_tree().process_frame
			_peer_connected(id)
	)
	
	multiplayer.set_multiplayer_peer(socket)
	_is_host = true
	
	log_status("\tSuccessfully initialized network.")
	return true # there were no errors

##
# Initialize a new socket object and attempts a connection.
#
# Params:
#         ip:            The ip the host is located on.
#         port:          The port used to connect to the host.
#         bandwidth_in:  (Optional) Limit bandwidth allowed in. 0 for none.
#         bandwidth_out: (Optional) Limit bandwidth allowed out. 0 for none.
#         ssl_cert:      (Optional) Full path to the '.crt' file used to connect.
#         ssl_host:      (Optional) Host name used to verify crt.
#         ssl_verify:    (Optional) 3rd party extra integrity check.
#
# Returns: If the socket initialization was successful or not.
##
func join(
	ip: String,
	port: int,
	bandwidth_in: int = 0,
	bandwidth_out: int = 0,
	ssl_cert: String = "",
	ssl_host: String = "",
	ssl_verify: bool = false
) -> bool:
	var socket := ENetMultiplayerPeer.new()
	
	log_status("Initializing network started.")
	
	if socket.create_client(ip, port, 2, bandwidth_in, bandwidth_out) != OK:
		log_status("\tFailed to initialize... Port may currently be in use!")
		return false # error
	
	# load tls data
	if ssl_cert.strip_escapes().length() > 0 and ssl_host.strip_escapes().length() > 0:
		log_status("\tActivating network security.")
		socket.get_host().dtls_client_setup(
			ssl_host,
			TLSOptions.client(load(ssl_cert)) if ssl_verify else null
		)
		log_status("\t\tSuccessfully activated security!")
	
	# connect peer events
	socket.peer_disconnected.connect(func(): _connection_failed(); terminate())
	socket.peer_connected.connect(
		func(id: int):
			await get_tree().process_frame
			_connection_succeeded()
	)
	
	multiplayer.set_multiplayer_peer(socket)
	return true # there were no errors

##
# Terminates the current active networking socket.
##
func terminate() -> void:
	# reset status
	_is_host = false
	
	# kill socket
	if socket_connected():
		get_socket().close_connection()
	multiplayer.set_multiplayer_peer(null)

##
# Receives a packet by header, and passes any args to the handler for the packet. If this packet is invalid, it will be refused.
#
# Params:
#         id:        : The target hybrid ENet socket connetion uuid.
#         header     : The packet header defined in the Packet.Hybrid enum.
#         args       : The packet data or arguments if any.
##
func _receive_data(id: int, header: Packet.Hybrid, args: Array[Variant]) -> void:
	# add id to the params
	args.append(id)
	
	# try to route the function
	if callv("receive_" + Packet.Hybrid.keys()[header], args) == true: return
	
	# if we reach this, we had an error calling the function or
	# we returned false intentionally from the function to signify
	# an invalid call state. (hacking attempt possibly?)
	socket_disconnect(id)
	
	# debug printing
	log_debug(
		"A packet was refused... Packet info dump following:\n%s: %s" %
		[Packet.Hybrid.keys()[header], args]
	)
 
##
# Returns the current state of the active socket connection.
#
# Params:
#         id: ENet socket connetion uuid. (1 for host)
##
func socket_state(id: int = 1) -> int:
	# self connection
	if _is_host and (id == 0 or id == 1):
		return ENetPacketPeer.STATE_CONNECTED
	
	# external connection
	var socket := get_socket()
	if not is_instance_valid(socket):
		return ENetPacketPeer.STATE_DISCONNECTED
	
	if id not in multiplayer.get_peers():
		return ENetPacketPeer.STATE_DISCONNECTED
	
	var peer := socket.get_peer(id)
	if not is_instance_valid(peer):
		return ENetPacketPeer.STATE_DISCONNECTED
	
	return peer.get_state()

##
# Returns if the current active socket connection is connected or not.
#
# Params:
#         id: ENet socket connetion uuid. (1 for host)
##
func socket_connected(id: int = 1) -> bool:
	return socket_state(id) == ENetPacketPeer.STATE_CONNECTED

##
# Ends the current active socket connection if connected.
#
# Params:
#         id: ENet socket connetion uuid. (1 for host)
##
func socket_disconnect(id: int = 1) -> void:
	if _is_host:
		if id == 0: return
		if not socket_connected(id): return
		get_socket().get_peer(id).peer_disconnect()
	else:
		terminate()
		
		# notify the connection loss
		_connection_ended()

##
# Sends a packet to the specified connection.
#
# Params:
#         id:        : The target ENet socket connetion uuid. (1 for host)
#         header     : The packet header defined in the Packet.Hybrid enum.
#         args       : The packet data or arguments if any.
#         unreliable : Opts to allow unreliable transport. Good for speed, dangerous for syncrosity.
#         channel    : The channel number to send on.
##
func socket_send_to(
	id         : int,
	header     : Packet.Hybrid,
	args       : Array[Variant] = [],
	unreliable : bool = false,
	channel    : int = 1
) -> void:
	# send to self
	if _is_host and (id == 0 or id == 1):
		_receive_data(id, header, args)
	
	# send to external
	if not socket_connected(id): return
	var fn = "hybrid_receive_%sreliable_channel_%s" % [("un" if unreliable else ""), str(clamp(channel, 1, 2))]
	rpc_id(id, fn, header, args)

##
# Returns the current active socket connections ip.
#
# Params:
#         id: ENet socket connetion uuid. (1 for host)
##
func socket_ip(id: int = 1) -> String:
	if id == 0 or id == 1: return "127.0.0.1"
	
	if not socket_connected(id): return "0.0.0.0"
	return get_socket().get_peer(id).get_remote_address()
