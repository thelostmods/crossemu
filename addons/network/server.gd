class_name ServerNetwork extends Network

################################################################################
#                        Copyright 2022-2023 ArchaicSoft                       #
#                                                                              #
# Boost Software License - Version 1.0 - August 17th, 2003                     #
#                                                                              #
# Permission is hereby granted, free of charge, to any person or organization  #
# obtaining a copy of the software and accompanying documentation covered by   #
# this license (the "Software") to use, reproduce, display, distribute,        #
# execute, and transmit the Software, and to prepare derivative works of the   #
# Software, and to permit third-parties to whom the Software is furnished to   #
# do so, all subject to the following:                                         #
#                                                                              #
# The copyright notices in the Software and this entire statement, including   #
# the above license grant, this restriction and the following disclaimer,      #
# must be included in all copies of the Software, in whole or in part, and     #
# all derivative works of the Software, unless such copies or derivative       #
# works are solely in the form of machine-executable object code generated by  #
# a source language processor.                                                 #
#                                                                              #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,     #
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT    #
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE    #
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,  #
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  #
# DEALINGS IN THE SOFTWARE.                                                    #
################################################################################

# remote accessors

@rpc("any_peer", "reliable", "call_remote", 0)
func server_receive_reliable_channel_1(header: Packet.Client, args: Array[Variant]) -> void:
	_receive_data(multiplayer.get_remote_sender_id(), header, args)

@rpc("any_peer", "reliable", "call_remote", 1)
func server_receive_reliable_channel_2(header: Packet.Client, args: Array[Variant]) -> void:
	_receive_data(multiplayer.get_remote_sender_id(), header, args)

@rpc("any_peer", "unreliable", "call_remote", 2)
func server_receive_unreliable_channel_1(header: Packet.Client, args: Array[Variant]) -> void:
	_receive_data(multiplayer.get_remote_sender_id(), header, args)

@rpc("any_peer", "unreliable", "call_remote", 3)
func server_receive_unreliable_channel_2(header: Packet.Client, args: Array[Variant]) -> void:
	_receive_data(multiplayer.get_remote_sender_id(), header, args)

##
# User-Defined event for interacting on a peer connect signal.
#
# Params:
#         id: ENet socket connetion uuid.
##
func _peer_connected(id: int) -> void: pass

##
# User-Defined event for interacting on a peer disconnect signal.
#
# Params:
#         id: ENet socket connetion uuid.
##
func _peer_disconnected(id: int) -> void: pass

##
# Initialize a new socket object and listens for connections.
#
# Params:
#         port:          The port used to connect to the server.
#         max_clients:   Limit of client connections allowed.
#         bandwidth_in:  (Optional) Limit bandwidth allowed in. 0 for none.
#         bandwidth_out: (Optional) Limit bandwidth allowed out. 0 for none.
#         ssl_pkey:      (Optional) Full path to the '.key' file used to service.
#         ssl_cert:      (Optional) Full path to the '.crt' file used to service.
#
# Returns: If the socket initialization was successful or not.
##
func initialize(
	port: int,
	max_clients: int,
	bandwidth_in: int = 0,
	bandwidth_out: int = 0,
	ssl_pkey: String = "",
	ssl_cert: String = ""
) -> bool:
	var socket := ENetMultiplayerPeer.new()
	
	log_status("Initializing network started.")
	
	if socket.create_server(port, max_clients, 4, bandwidth_in, bandwidth_out) != OK:
		log_status("\tFailed to initialize... Port may currently be in use!")
		return false # error
	
	# load tls data
	if ssl_pkey.strip_escapes().length() > 0 and ssl_cert.strip_escapes().length() > 0:
		log_status("\tActivating network security.")
		socket.get_host().dtls_server_setup(
			TLSOptions.server(load(ssl_pkey), load(ssl_cert))
		)
		log_status("\t\tSuccessfully activated security!")
	
	log_status("\tApplying final steps to the network.")
	
	# connect peer events
	socket.peer_disconnected.connect(_peer_disconnected)
	socket.peer_connected.connect(
		func(id:int):
			await get_tree().process_frame
			_peer_connected(id)
	)
	
	multiplayer.set_multiplayer_peer(socket)
	
	log_status("\tSuccessfully initialized network.")
	return true # there were no errors

##
# Terminates the current active networking socket.
##
func terminate() -> void:
	var socket := get_socket()
	if is_instance_valid(socket):
		socket.close_connection()
	multiplayer.set_multiplayer_peer(null)

##
# Receives a packet by header, and passes any args to the handler for the packet. If this packet is invalid, it will be refused.
#
# Params:
#         id:        : The target clients ENet socket connetion uuid.
#         header     : The packet header defined in the Packet.Client enum.
#         args       : The packet data or arguments if any.
##
func _receive_data(id: int, header: Packet.Client, args: Array[Variant]) -> void:
	# add id to the params
	args.append(id)
	
	# try to route the function
	if callv("receive_" + Packet.Client.keys()[header], args) == true: return
	
	# if we reach this, we had an error calling the function or
	# we returned false intentionally from the function to signify
	# an invalid call state. (hacking attempt possibly?)
	socket_disconnect(id)
	
	# debug printing
	log_debug("A packet was refused... Packet info dump following:")
	log_debug("%s: %s" % [Packet.Client.keys()[header], args])
 
##
# Returns the current state of the active socket connection.
#
# Params:
#         id: ENet socket connetion uuid.
##
func socket_state(id: int) -> int:
	var socket := get_socket()
	if not is_instance_valid(socket):
		return ENetPacketPeer.STATE_DISCONNECTED
	
	if id not in multiplayer.get_peers():
		return ENetPacketPeer.STATE_DISCONNECTED
	
	var peer := socket.get_peer(id)
	if not is_instance_valid(peer):
		return ENetPacketPeer.STATE_DISCONNECTED
	
	return peer.get_state()

##
# Returns if the current active socket connection is connected or not.
#
# Params:
#         id: ENet socket connetion uuid.
##
func socket_connected(id: int) -> bool:
	return socket_state(id) == ENetPacketPeer.STATE_CONNECTED

##
# Ends the current active socket connection if connected.
#
# Params:
#         id: ENet socket connetion uuid.
##
func socket_disconnect(id: int) -> void:
	if not socket_connected(id): return
	get_socket().get_peer(id).peer_disconnect()

##
# Sends a packet to the specified client.
#
# Params:
#         id:        : The target clients ENet socket connetion uuid.
#         header     : The packet header defined in the Packet.Server enum.
#         args       : The packet data or arguments if any.
#         unreliable : Opts to allow unreliable transport. Good for speed, dangerous for syncrosity.
##
func socket_send_to(
	id         : int,
	header     : Packet.Server,
	args       : Array[Variant] = [],
	unreliable : bool = false
) -> void:
	if not socket_connected(id): return
	var fn = "client_receive_%sreliable" % ("un" if unreliable else "")
	rpc_id(id, fn, header, args)

##
# Returns the current active socket connections ip.
#
# Params:
#         id: ENet socket connetion uuid.
##
func socket_ip(id: int) -> String:
	if not socket_connected(id): return "0.0.0.0"
	return get_socket().get_peer(id).get_remote_address()
